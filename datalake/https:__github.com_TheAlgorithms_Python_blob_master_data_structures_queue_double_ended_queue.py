<body>
 """ Implementation of double ended queue. """ from __future__ import annotations from collections.abc import Iterable from dataclasses import dataclass from typing import Any class Deque: """ Deque data structure. Operations ---------- append(val: Any) -&gt; None appendleft(val: Any) -&gt; None extend(iterable: Iterable) -&gt; None extendleft(iterable: Iterable) -&gt; None pop() -&gt; Any popleft() -&gt; Any Observers --------- is_empty() -&gt; bool Attributes ---------- _front: _Node front of the deque a.k.a. the first element _back: _Node back of the element a.k.a. the last element _len: int the number of nodes """ __slots__ = ("_front", "_back", "_len") @dataclass class _Node: """ Representation of a node. Contains a value and a pointer to the next node as well as to the previous one. """ val: Any = None next_node: Deque._Node | None = None prev_node: Deque._Node | None = None class _Iterator: """ Helper class for iteration. Will be used to implement iteration. Attributes ---------- _cur: _Node the current node of the iteration. """ __slots__ = ("_cur",) def __init__(self, cur: Deque._Node | None) -&gt; None: self._cur = cur def __iter__(self) -&gt; Deque._Iterator: """ &gt;&gt;&gt; our_deque = Deque([1, 2, 3]) &gt;&gt;&gt; iterator = iter(our_deque) """ return self def __next__(self) -&gt; Any: """ &gt;&gt;&gt; our_deque = Deque([1, 2, 3]) &gt;&gt;&gt; iterator = iter(our_deque) &gt;&gt;&gt; next(iterator) 1 &gt;&gt;&gt; next(iterator) 2 &gt;&gt;&gt; next(iterator) 3 """ if self._cur is None: # finished iterating raise StopIteration val = self._cur.val self._cur = self._cur.next_node return val def __init__(self, iterable: Iterable[Any] | None = None) -&gt; None: self._front: Any = None self._back: Any = None self._len: int = 0 if iterable is not None: # append every value to the deque for val in iterable: self.append(val) def append(self, val: Any) -&gt; None: """ Adds val to the end of the deque. Time complexity: O(1) &gt;&gt;&gt; our_deque_1 = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque_1.append(4) &gt;&gt;&gt; our_deque_1 [1, 2, 3, 4] &gt;&gt;&gt; our_deque_2 = Deque('ab') &gt;&gt;&gt; our_deque_2.append('c') &gt;&gt;&gt; our_deque_2 ['a', 'b', 'c'] &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections_1 = deque([1, 2, 3]) &gt;&gt;&gt; deque_collections_1.append(4) &gt;&gt;&gt; deque_collections_1 deque([1, 2, 3, 4]) &gt;&gt;&gt; deque_collections_2 = deque('ab') &gt;&gt;&gt; deque_collections_2.append('c') &gt;&gt;&gt; deque_collections_2 deque(['a', 'b', 'c']) &gt;&gt;&gt; list(our_deque_1) == list(deque_collections_1) True &gt;&gt;&gt; list(our_deque_2) == list(deque_collections_2) True """ node = self._Node(val, None, None) if self.is_empty(): # front = back self._front = self._back = node self._len = 1 else: # connect nodes self._back.next_node = node node.prev_node = self._back self._back = node # assign new back to the new node self._len += 1 # make sure there were no errors assert not self.is_empty(), "Error on appending value." def appendleft(self, val: Any) -&gt; None: """ Adds val to the beginning of the deque. Time complexity: O(1) &gt;&gt;&gt; our_deque_1 = Deque([2, 3]) &gt;&gt;&gt; our_deque_1.appendleft(1) &gt;&gt;&gt; our_deque_1 [1, 2, 3] &gt;&gt;&gt; our_deque_2 = Deque('bc') &gt;&gt;&gt; our_deque_2.appendleft('a') &gt;&gt;&gt; our_deque_2 ['a', 'b', 'c'] &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections_1 = deque([2, 3]) &gt;&gt;&gt; deque_collections_1.appendleft(1) &gt;&gt;&gt; deque_collections_1 deque([1, 2, 3]) &gt;&gt;&gt; deque_collections_2 = deque('bc') &gt;&gt;&gt; deque_collections_2.appendleft('a') &gt;&gt;&gt; deque_collections_2 deque(['a', 'b', 'c']) &gt;&gt;&gt; list(our_deque_1) == list(deque_collections_1) True &gt;&gt;&gt; list(our_deque_2) == list(deque_collections_2) True """ node = self._Node(val, None, None) if self.is_empty(): # front = back self._front = self._back = node self._len = 1 else: # connect nodes node.next_node = self._front self._front.prev_node = node self._front = node # assign new front to the new node self._len += 1 # make sure there were no errors assert not self.is_empty(), "Error on appending value." def extend(self, iterable: Iterable[Any]) -&gt; None: """ Appends every value of iterable to the end of the deque. Time complexity: O(n) &gt;&gt;&gt; our_deque_1 = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque_1.extend([4, 5]) &gt;&gt;&gt; our_deque_1 [1, 2, 3, 4, 5] &gt;&gt;&gt; our_deque_2 = Deque('ab') &gt;&gt;&gt; our_deque_2.extend('cd') &gt;&gt;&gt; our_deque_2 ['a', 'b', 'c', 'd'] &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections_1 = deque([1, 2, 3]) &gt;&gt;&gt; deque_collections_1.extend([4, 5]) &gt;&gt;&gt; deque_collections_1 deque([1, 2, 3, 4, 5]) &gt;&gt;&gt; deque_collections_2 = deque('ab') &gt;&gt;&gt; deque_collections_2.extend('cd') &gt;&gt;&gt; deque_collections_2 deque(['a', 'b', 'c', 'd']) &gt;&gt;&gt; list(our_deque_1) == list(deque_collections_1) True &gt;&gt;&gt; list(our_deque_2) == list(deque_collections_2) True """ for val in iterable: self.append(val) def extendleft(self, iterable: Iterable[Any]) -&gt; None: """ Appends every value of iterable to the beginning of the deque. Time complexity: O(n) &gt;&gt;&gt; our_deque_1 = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque_1.extendleft([0, -1]) &gt;&gt;&gt; our_deque_1 [-1, 0, 1, 2, 3] &gt;&gt;&gt; our_deque_2 = Deque('cd') &gt;&gt;&gt; our_deque_2.extendleft('ba') &gt;&gt;&gt; our_deque_2 ['a', 'b', 'c', 'd'] &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections_1 = deque([1, 2, 3]) &gt;&gt;&gt; deque_collections_1.extendleft([0, -1]) &gt;&gt;&gt; deque_collections_1 deque([-1, 0, 1, 2, 3]) &gt;&gt;&gt; deque_collections_2 = deque('cd') &gt;&gt;&gt; deque_collections_2.extendleft('ba') &gt;&gt;&gt; deque_collections_2 deque(['a', 'b', 'c', 'd']) &gt;&gt;&gt; list(our_deque_1) == list(deque_collections_1) True &gt;&gt;&gt; list(our_deque_2) == list(deque_collections_2) True """ for val in iterable: self.appendleft(val) def pop(self) -&gt; Any: """ Removes the last element of the deque and returns it. Time complexity: O(1) @returns topop.val: the value of the node to pop. &gt;&gt;&gt; our_deque1 = Deque([1]) &gt;&gt;&gt; our_popped1 = our_deque1.pop() &gt;&gt;&gt; our_popped1 1 &gt;&gt;&gt; our_deque1 [] &gt;&gt;&gt; our_deque2 = Deque([1, 2, 3, 15182]) &gt;&gt;&gt; our_popped2 = our_deque2.pop() &gt;&gt;&gt; our_popped2 15182 &gt;&gt;&gt; our_deque2 [1, 2, 3] &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections = deque([1, 2, 3, 15182]) &gt;&gt;&gt; collections_popped = deque_collections.pop() &gt;&gt;&gt; collections_popped 15182 &gt;&gt;&gt; deque_collections deque([1, 2, 3]) &gt;&gt;&gt; list(our_deque2) == list(deque_collections) True &gt;&gt;&gt; our_popped2 == collections_popped True """ # make sure the deque has elements to pop assert not self.is_empty(), "Deque is empty." topop = self._back # if only one element in the queue: point the front and back to None # else remove one element from back if self._front == self._back: self._front = None self._back = None else: self._back = self._back.prev_node # set new back # drop the last node, python will deallocate memory automatically self._back.next_node = None self._len -= 1 return topop.val def popleft(self) -&gt; Any: """ Removes the first element of the deque and returns it. Time complexity: O(1) @returns topop.val: the value of the node to pop. &gt;&gt;&gt; our_deque1 = Deque([1]) &gt;&gt;&gt; our_popped1 = our_deque1.pop() &gt;&gt;&gt; our_popped1 1 &gt;&gt;&gt; our_deque1 [] &gt;&gt;&gt; our_deque2 = Deque([15182, 1, 2, 3]) &gt;&gt;&gt; our_popped2 = our_deque2.popleft() &gt;&gt;&gt; our_popped2 15182 &gt;&gt;&gt; our_deque2 [1, 2, 3] &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections = deque([15182, 1, 2, 3]) &gt;&gt;&gt; collections_popped = deque_collections.popleft() &gt;&gt;&gt; collections_popped 15182 &gt;&gt;&gt; deque_collections deque([1, 2, 3]) &gt;&gt;&gt; list(our_deque2) == list(deque_collections) True &gt;&gt;&gt; our_popped2 == collections_popped True """ # make sure the deque has elements to pop assert not self.is_empty(), "Deque is empty." topop = self._front # if only one element in the queue: point the front and back to None # else remove one element from front if self._front == self._back: self._front = None self._back = None else: self._front = self._front.next_node # set new front and drop the first node self._front.prev_node = None self._len -= 1 return topop.val def is_empty(self) -&gt; bool: """ Checks if the deque is empty. Time complexity: O(1) &gt;&gt;&gt; our_deque = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque.is_empty() False &gt;&gt;&gt; our_empty_deque = Deque() &gt;&gt;&gt; our_empty_deque.is_empty() True &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; empty_deque_collections = deque() &gt;&gt;&gt; list(our_empty_deque) == list(empty_deque_collections) True """ return self._front is None def __len__(self) -&gt; int: """ Implements len() function. Returns the length of the deque. Time complexity: O(1) &gt;&gt;&gt; our_deque = Deque([1, 2, 3]) &gt;&gt;&gt; len(our_deque) 3 &gt;&gt;&gt; our_empty_deque = Deque() &gt;&gt;&gt; len(our_empty_deque) 0 &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections = deque([1, 2, 3]) &gt;&gt;&gt; len(deque_collections) 3 &gt;&gt;&gt; empty_deque_collections = deque() &gt;&gt;&gt; len(empty_deque_collections) 0 &gt;&gt;&gt; len(our_empty_deque) == len(empty_deque_collections) True """ return self._len def __eq__(self, other: object) -&gt; bool: """ Implements "==" operator. Returns if *self* is equal to *other*. Time complexity: O(n) &gt;&gt;&gt; our_deque_1 = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque_2 = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque_1 == our_deque_2 True &gt;&gt;&gt; our_deque_3 = Deque([1, 2]) &gt;&gt;&gt; our_deque_1 == our_deque_3 False &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections_1 = deque([1, 2, 3]) &gt;&gt;&gt; deque_collections_2 = deque([1, 2, 3]) &gt;&gt;&gt; deque_collections_1 == deque_collections_2 True &gt;&gt;&gt; deque_collections_3 = deque([1, 2]) &gt;&gt;&gt; deque_collections_1 == deque_collections_3 False &gt;&gt;&gt; (our_deque_1 == our_deque_2) == (deque_collections_1 == deque_collections_2) True &gt;&gt;&gt; (our_deque_1 == our_deque_3) == (deque_collections_1 == deque_collections_3) True """ if not isinstance(other, Deque): return NotImplemented me = self._front oth = other._front # if the length of the dequeues are not the same, they are not equal if len(self) != len(other): return False while me is not None and oth is not None: # compare every value if me.val != oth.val: return False me = me.next_node oth = oth.next_node return True def __iter__(self) -&gt; Deque._Iterator: """ Implements iteration. Time complexity: O(1) &gt;&gt;&gt; our_deque = Deque([1, 2, 3]) &gt;&gt;&gt; for v in our_deque: ... print(v) 1 2 3 &gt;&gt;&gt; from collections import deque &gt;&gt;&gt; deque_collections = deque([1, 2, 3]) &gt;&gt;&gt; for v in deque_collections: ... print(v) 1 2 3 """ return Deque._Iterator(self._front) def __repr__(self) -&gt; str: """ Implements representation of the deque. Represents it as a list, with its values between '[' and ']'. Time complexity: O(n) &gt;&gt;&gt; our_deque = Deque([1, 2, 3]) &gt;&gt;&gt; our_deque [1, 2, 3] """ values_list = [] aux = self._front while aux is not None: # append the values in a list to display values_list.append(aux.val) aux = aux.next_node return f"[{', '.join(repr(val) for val in values_list)}]" if __name__ == "__main__": import doctest doctest.testmod() dq = Deque([3]) dq.pop()
</body>