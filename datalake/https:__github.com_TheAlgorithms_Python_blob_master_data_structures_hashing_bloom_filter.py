<body>
 """ See https://en.wikipedia.org/wiki/Bloom_filter The use of this data structure is to test membership in a set. Compared to Python's built-in set() it is more space-efficient. In the following example, only 8 bits of memory will be used: &gt;&gt;&gt; bloom = Bloom(size=8) Initially, the filter contains all zeros: &gt;&gt;&gt; bloom.bitstring '00000000' When an element is added, two bits are set to 1 since there are 2 hash functions in this implementation: &gt;&gt;&gt; "Titanic" in bloom False &gt;&gt;&gt; bloom.add("Titanic") &gt;&gt;&gt; bloom.bitstring '01100000' &gt;&gt;&gt; "Titanic" in bloom True However, sometimes only one bit is added because both hash functions return the same value &gt;&gt;&gt; bloom.add("Avatar") &gt;&gt;&gt; "Avatar" in bloom True &gt;&gt;&gt; bloom.format_hash("Avatar") '00000100' &gt;&gt;&gt; bloom.bitstring '01100100' Not added elements should return False ... &gt;&gt;&gt; not_present_films = ("The Godfather", "Interstellar", "Parasite", "Pulp Fiction") &gt;&gt;&gt; { ... film: bloom.format_hash(film) for film in not_present_films ... } # doctest: +NORMALIZE_WHITESPACE {'The Godfather': '00000101', 'Interstellar': '00000011', 'Parasite': '00010010', 'Pulp Fiction': '10000100'} &gt;&gt;&gt; any(film in bloom for film in not_present_films) False but sometimes there are false positives: &gt;&gt;&gt; "Ratatouille" in bloom True &gt;&gt;&gt; bloom.format_hash("Ratatouille") '01100000' The probability increases with the number of elements added. The probability decreases with the number of bits in the bitarray. &gt;&gt;&gt; bloom.estimated_error_rate 0.140625 &gt;&gt;&gt; bloom.add("The Godfather") &gt;&gt;&gt; bloom.estimated_error_rate 0.25 &gt;&gt;&gt; bloom.bitstring '01100101' """ from hashlib import md5, sha256 HASH_FUNCTIONS = (sha256, md5) class Bloom: def __init__(self, size: int = 8) -&gt; None: self.bitarray = 0b0 self.size = size def add(self, value: str) -&gt; None: h = self.hash_(value) self.bitarray |= h def exists(self, value: str) -&gt; bool: h = self.hash_(value) return (h &amp; self.bitarray) == h def __contains__(self, other: str) -&gt; bool: return self.exists(other) def format_bin(self, bitarray: int) -&gt; str: res = bin(bitarray)[2:] return res.zfill(self.size) @property def bitstring(self) -&gt; str: return self.format_bin(self.bitarray) def hash_(self, value: str) -&gt; int: res = 0b0 for func in HASH_FUNCTIONS: position = ( int.from_bytes(func(value.encode()).digest(), "little") % self.size ) res |= 2**position return res def format_hash(self, value: str) -&gt; str: return self.format_bin(self.hash_(value)) @property def estimated_error_rate(self) -&gt; float: n_ones = bin(self.bitarray).count("1") return (n_ones / self.size) ** len(HASH_FUNCTIONS)
</body>