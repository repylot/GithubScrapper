<body>
 #!/usr/bin/env python3 from __future__ import annotations import random from collections.abc import Iterable from typing import Any, Generic, TypeVar T = TypeVar("T", bound=bool) class RandomizedHeapNode(Generic[T]): """ One node of the randomized heap. Contains the value and references to two children. """ def __init__(self, value: T) -&gt; None: self._value: T = value self.left: RandomizedHeapNode[T] | None = None self.right: RandomizedHeapNode[T] | None = None @property def value(self) -&gt; T: """ Return the value of the node. &gt;&gt;&gt; rhn = RandomizedHeapNode(10) &gt;&gt;&gt; rhn.value 10 &gt;&gt;&gt; rhn = RandomizedHeapNode(-10) &gt;&gt;&gt; rhn.value -10 """ return self._value @staticmethod def merge( root1: RandomizedHeapNode[T] | None, root2: RandomizedHeapNode[T] | None ) -&gt; RandomizedHeapNode[T] | None: """ Merge 2 nodes together. &gt;&gt;&gt; rhn1 = RandomizedHeapNode(10) &gt;&gt;&gt; rhn2 = RandomizedHeapNode(20) &gt;&gt;&gt; RandomizedHeapNode.merge(rhn1, rhn2).value 10 &gt;&gt;&gt; rhn1 = RandomizedHeapNode(20) &gt;&gt;&gt; rhn2 = RandomizedHeapNode(10) &gt;&gt;&gt; RandomizedHeapNode.merge(rhn1, rhn2).value 10 &gt;&gt;&gt; rhn1 = RandomizedHeapNode(5) &gt;&gt;&gt; rhn2 = RandomizedHeapNode(0) &gt;&gt;&gt; RandomizedHeapNode.merge(rhn1, rhn2).value 0 """ if not root1: return root2 if not root2: return root1 if root1.value &gt; root2.value: root1, root2 = root2, root1 if random.choice([True, False]): root1.left, root1.right = root1.right, root1.left root1.left = RandomizedHeapNode.merge(root1.left, root2) return root1 class RandomizedHeap(Generic[T]): """ A data structure that allows inserting a new value and to pop the smallest values. Both operations take O(logN) time where N is the size of the structure. Wiki: https://en.wikipedia.org/wiki/Randomized_meldable_heap &gt;&gt;&gt; RandomizedHeap([2, 3, 1, 5, 1, 7]).to_sorted_list() [1, 1, 2, 3, 5, 7] &gt;&gt;&gt; rh = RandomizedHeap() &gt;&gt;&gt; rh.pop() Traceback (most recent call last): ... IndexError: Can't get top element for the empty heap. &gt;&gt;&gt; rh.insert(1) &gt;&gt;&gt; rh.insert(-1) &gt;&gt;&gt; rh.insert(0) &gt;&gt;&gt; rh.to_sorted_list() [-1, 0, 1] """ def __init__(self, data: Iterable[T] | None = ()) -&gt; None: """ &gt;&gt;&gt; rh = RandomizedHeap([3, 1, 3, 7]) &gt;&gt;&gt; rh.to_sorted_list() [1, 3, 3, 7] """ self._root: RandomizedHeapNode[T] | None = None if data: for item in data: self.insert(item) def insert(self, value: T) -&gt; None: """ Insert the value into the heap. &gt;&gt;&gt; rh = RandomizedHeap() &gt;&gt;&gt; rh.insert(3) &gt;&gt;&gt; rh.insert(1) &gt;&gt;&gt; rh.insert(3) &gt;&gt;&gt; rh.insert(7) &gt;&gt;&gt; rh.to_sorted_list() [1, 3, 3, 7] """ self._root = RandomizedHeapNode.merge(self._root, RandomizedHeapNode(value)) def pop(self) -&gt; T | None: """ Pop the smallest value from the heap and return it. &gt;&gt;&gt; rh = RandomizedHeap([3, 1, 3, 7]) &gt;&gt;&gt; rh.pop() 1 &gt;&gt;&gt; rh.pop() 3 &gt;&gt;&gt; rh.pop() 3 &gt;&gt;&gt; rh.pop() 7 &gt;&gt;&gt; rh.pop() Traceback (most recent call last): ... IndexError: Can't get top element for the empty heap. """ result = self.top() if self._root is None: return None self._root = RandomizedHeapNode.merge(self._root.left, self._root.right) return result def top(self) -&gt; T: """ Return the smallest value from the heap. &gt;&gt;&gt; rh = RandomizedHeap() &gt;&gt;&gt; rh.insert(3) &gt;&gt;&gt; rh.top() 3 &gt;&gt;&gt; rh.insert(1) &gt;&gt;&gt; rh.top() 1 &gt;&gt;&gt; rh.insert(3) &gt;&gt;&gt; rh.top() 1 &gt;&gt;&gt; rh.insert(7) &gt;&gt;&gt; rh.top() 1 """ if not self._root: raise IndexError("Can't get top element for the empty heap.") return self._root.value def clear(self) -&gt; None: """ Clear the heap. &gt;&gt;&gt; rh = RandomizedHeap([3, 1, 3, 7]) &gt;&gt;&gt; rh.clear() &gt;&gt;&gt; rh.pop() Traceback (most recent call last): ... IndexError: Can't get top element for the empty heap. """ self._root = None def to_sorted_list(self) -&gt; list[Any]: """ Returns sorted list containing all the values in the heap. &gt;&gt;&gt; rh = RandomizedHeap([3, 1, 3, 7]) &gt;&gt;&gt; rh.to_sorted_list() [1, 3, 3, 7] """ result = [] while self: result.append(self.pop()) return result def __bool__(self) -&gt; bool: """ Check if the heap is not empty. &gt;&gt;&gt; rh = RandomizedHeap() &gt;&gt;&gt; bool(rh) False &gt;&gt;&gt; rh.insert(1) &gt;&gt;&gt; bool(rh) True &gt;&gt;&gt; rh.clear() &gt;&gt;&gt; bool(rh) False """ return self._root is not None if __name__ == "__main__": import doctest doctest.testmod()
</body>