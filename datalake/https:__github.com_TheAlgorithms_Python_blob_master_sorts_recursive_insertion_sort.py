<body>
 """ A recursive implementation of the insertion sort algorithm """ from __future__ import annotations def rec_insertion_sort(collection: list, n: int): """ Given a collection of numbers and its length, sorts the collections in ascending order :param collection: A mutable collection of comparable elements :param n: The length of collections &gt;&gt;&gt; col = [1, 2, 1] &gt;&gt;&gt; rec_insertion_sort(col, len(col)) &gt;&gt;&gt; col [1, 1, 2] &gt;&gt;&gt; col = [2, 1, 0, -1, -2] &gt;&gt;&gt; rec_insertion_sort(col, len(col)) &gt;&gt;&gt; col [-2, -1, 0, 1, 2] &gt;&gt;&gt; col = [1] &gt;&gt;&gt; rec_insertion_sort(col, len(col)) &gt;&gt;&gt; col [1] """ # Checks if the entire collection has been sorted if len(collection) &lt;= 1 or n &lt;= 1: return insert_next(collection, n - 1) rec_insertion_sort(collection, n - 1) def insert_next(collection: list, index: int): """ Inserts the '(index-1)th' element into place &gt;&gt;&gt; col = [3, 2, 4, 2] &gt;&gt;&gt; insert_next(col, 1) &gt;&gt;&gt; col [2, 3, 4, 2] &gt;&gt;&gt; col = [3, 2, 3] &gt;&gt;&gt; insert_next(col, 2) &gt;&gt;&gt; col [3, 2, 3] &gt;&gt;&gt; col = [] &gt;&gt;&gt; insert_next(col, 1) &gt;&gt;&gt; col [] """ # Checks order between adjacent elements if index &gt;= len(collection) or collection[index - 1] &lt;= collection[index]: return # Swaps adjacent elements since they are not in ascending order collection[index - 1], collection[index] = ( collection[index], collection[index - 1], ) insert_next(collection, index + 1) if __name__ == "__main__": numbers = input("Enter integers separated by spaces: ") number_list: list[int] = [int(num) for num in numbers.split()] rec_insertion_sort(number_list, len(number_list)) print(number_list)
</body>